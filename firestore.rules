rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -----------------------------
    // Helpers
    // -----------------------------
    function isSignedIn() {
      return request.auth != null;
    }
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    function userDoc(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }
    function isClient(uid) {
      return isSignedIn() && userDoc(uid).data.userType == 'client';
    }
    function isFreelancer(uid) {
      return isSignedIn() && userDoc(uid).data.userType == 'freelancer';
    }
    // Safe for document reads; avoid relying on this for queries.
    function projectDoc(projectId) {
      return get(/databases/$(database)/documents/projects/$(projectId));
    }

    // -----------------------------
    // Users: each user manages their own doc
    // -----------------------------
    match /users/{userId} {
      allow read: if isOwner(userId) ||
                   (resource.data.userType == 'freelancer' && resource.data.visibility == 'public');
      allow create: if isOwner(userId);
      allow update, delete: if isOwner(userId);
    }

    // -----------------------------
    // Jobs
    // -----------------------------
    match /jobs/{jobId} {
      allow read: if isSignedIn();

      // Create by the signed-in client (path-based auth)
      allow create: if isSignedIn() &&
                    request.resource.data.clientId == request.auth.uid;

      // Only the job owner can modify
      allow update, delete: if isSignedIn() &&
                            resource.data.clientId == request.auth.uid;

      // (Optional) legacy nested proposals kept for compatibility
      match /proposals/{proposalId} {
        allow read: if isSignedIn() &&
          (resource.data.freelancerId == request.auth.uid ||
           resource.data.clientId == request.auth.uid);
        allow create: if isSignedIn() &&
          request.resource.data.freelancerId == request.auth.uid;
        allow update, delete: if isSignedIn() &&
          (resource.data.clientId == request.auth.uid ||
           resource.data.freelancerId == request.auth.uid);
      }
    }

    // -----------------------------
    // Proposals (top-level, used by your UI)
    // -----------------------------
    match /proposals/{proposalId} {
      allow read: if isSignedIn() &&
        (resource.data.freelancerId == request.auth.uid ||
         resource.data.clientId == request.auth.uid);

      allow create: if isSignedIn() &&
        request.resource.data.freelancerId == request.auth.uid;

      // Allow write (covers update) for batch operations during approval
      allow write: if isSignedIn() &&
        (request.resource.data.clientId == request.auth.uid ||
         request.resource.data.freelancerId == request.auth.uid);

      allow update, delete: if isSignedIn() &&
        (resource.data.clientId == request.auth.uid ||
         resource.data.freelancerId == request.auth.uid);
    }

    // -----------------------------
    // Projects (created when a proposal is approved)
    // -----------------------------
    match /projects/{projectId} {
      // Create by signed-in caller if they are the client on the new doc
      allow create: if isSignedIn() &&
                    request.resource.data.clientId == request.auth.uid;

      // Read by participants (doc-based so queries work)
      // Allow read if document exists and user is participant, OR if document doesn't exist (for approval process)
      allow read: if isSignedIn() && (
        (resource != null && (resource.data.clientId == request.auth.uid ||
                             resource.data.freelancerId == request.auth.uid)) ||
        resource == null
      );

      // Write (covers both create and update) - allow if user is the client in the data
      // This handles batch.set() with merge:true during proposal approval
      allow write: if isSignedIn() &&
                   request.resource.data.clientId == request.auth.uid;

      // Update by participants (for existing projects)
      allow update: if isSignedIn() && (
        resource.data.clientId == request.auth.uid ||
        resource.data.freelancerId == request.auth.uid
      );

      // Delete by participants (keep doc-based check)
      allow delete: if isSignedIn() &&
        (resource.data.clientId == request.auth.uid ||
         resource.data.freelancerId == request.auth.uid);

      // Segments under a project
      match /segments/{segmentId} {
        // Read if listed on the segment OR a participant via parent
        allow read: if isSignedIn() && (
          (resource.data.clientId == request.auth.uid ||
           resource.data.freelancerId == request.auth.uid) ||
          projectDoc(projectId).data.clientId == request.auth.uid ||
          projectDoc(projectId).data.freelancerId == request.auth.uid
        );

        // Create if caller is the project freelancer OR segment declares them
        allow create: if isSignedIn() && (
          projectDoc(projectId).data.freelancerId == request.auth.uid ||
          request.resource.data.freelancerId == request.auth.uid
        );

        // Update/Delete by parent project participants
        allow update, delete: if isSignedIn() && (
          projectDoc(projectId).data.clientId == request.auth.uid ||
          projectDoc(projectId).data.freelancerId == request.auth.uid
        );
      }
    }

    // -----------------------------
    // Chats and Messages
    // -----------------------------
    match /chats/{chatId} {
      allow read, update, delete: if isSignedIn() &&
        request.auth.uid in resource.data.participants;

      allow create: if isSignedIn() &&
        request.resource.data.participants != null &&
        request.auth.uid in request.resource.data.participants;

      match /messages/{messageId} {
        allow read: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        allow create: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants &&
          request.resource.data.senderId == request.auth.uid;
        allow update, delete: if isSignedIn() &&
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      }
    }

    // -----------------------------
    // Notifications
    // -----------------------------
    match /notifications/{notifId} {
      allow read, update, delete: if isSignedIn() &&
                                  resource.data.userId == request.auth.uid;
      allow create: if isSignedIn();
    }

    // -----------------------------
    // Collection Group Queries (for segments across projects)
    // -----------------------------
    match /{path=**}/segments/{segmentId} {
      allow read: if isSignedIn() && (
        resource.data.clientId == request.auth.uid ||
        resource.data.freelancerId == request.auth.uid
      );
    }
  }
}
